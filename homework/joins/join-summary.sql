/*
Это попытка объяснить всем читающим как работают JOIN'ы в PostgreSQL.
Попытка оформлена в виде конспекта, к которому можно возвращаться.
*/


-- Здесть описано создание двух таблиц и их заполнение.
-- Эти запросы можно выполнять прямо без раскомментирования, просто выделив нужный запрос курсором.
/*
CREATE TABLE IF NOT EXISTS t1 (
	a1 text,
	b1 text
);
CREATE TABLE IF NOT EXISTS t2 (
	a2 text,
	b2 text
);

INSERT INTO t1
VALUES
(1, 'a'),
(2, 'b'),
(3, 'c');
INSERT INTO t2
VALUES
(1, 'x'),
(2, 'y'),
(4, 'z');
*/


-- Здесь описано удаление каждой из двух таблиц.
/*
DROP TABLE t1;
DROP TABLE t2;
*/


-- Алгоритмы работы JOIN'ов на пальцах:
/*
Есть 2 таблицы: t1 и t2. Эти таблицы джойнят по колонкам a1=a2.

     t1             t2
+----+----+    +----+----+
| a1 | b1 |    | a2 | b2 |
+----+----+    +----+----+
| 1  | a  |    | 1  | x  |
| 2  | b  |    | 2  | y  |
| 3  | c  |    | 4  | z  |
+----+----+    +----+----+


A. INNER JOIN (JOIN)
<SELECT * FROM t1 JOIN t2 ON t1.a1 = t2.a2>

В итоговой таблице окажутся только те строки, у которых значения a1 и a2 совпадают.

Алгоритм:
1. БД получает очередное значение в t1.a1;
2a. Если такое значение есть в t2.a2, то БД добавит данную строку в итоговую таблицу;
2b. Если такого значения нет в t2.a2, то БД перейдёт к получению следующего значения из t1.a1;

Результат:
+----+----+----+----+
| a1 | b1 | a2 | b2 |
+----+----+----+----+
| 1  | a  | 1  | x  |
| 2  | b  | 2  | y  |
+----+----+----+----+


B. LEFT JOIN
<SELECT * FROM t1 LEFT JOIN t2 ON t1.a1 = t2.a2>

В итоговой таблице окажутся строки со всеми значениями из a1 (тк t1 - левая таблица)
но не со всеми значениями из а2.

Алгоритм:
1. БД получает очередное значение в t1.a1;
2a. Если такое значение есть в t2.a2, то БД добавит данную строку в итоговую таблицу;
2b. Если такого значения нет в t2.a2, то БД тоже добавит данную строку в итоговую таблицу.
    В такой строке все колонки из t2 будут null;

Результат:
+----+----+------+------+
| a1 | b1 |  a2  |  b2  |
+----+----+------+------+
| 1  | a  |  1   |  x   |
| 2  | b  |  2   |  y   |
| 3  | c  | null | null |
+----+----+------+------+


C. RIGHT JOIN
<SELECT * FROM t1 RIGHT JOIN t2 ON t1.a1 = t2.a2>

Будет работать как запрос с LEFT JOIN (только порядок колонок будет другой)
если таблицы в нём поменять местами. То есть в итоговой таблице окажутся строки
со всеми значениями из a2 (тк t2 - правая таблица) но не со всеми значениями из а1.

Алгоритм:
1. БД получает очередное значение в t2.a2;
2a. Если такое значение есть в t1.a1, то БД добавит данную строку в итоговую таблицу;
2b. Если такого значения нет в t1.a1, то БД тоже добавит данную строку в итоговую таблицу.
    В такой строке все колонки из t1 будут null;

Результат:
+------+------+----+----+
|  a1  |  b1  | a2 | b2 |
+------+------+----+----+
|  1   |  a   | 1  | x  |
|  2   |  b   | 2  | y  |
| null | null | 4  | z  |
+------+------+----+----+


D. FULL JOIN
<SELECT * FROM t1 FULL JOIN t2 ON t1.a1 = t2.a2>

Будет работать сначала как LEFT JOIN, а потом как RIGHT JOIN.
Дублирующих строк в итоговой таблице не будет.

Алгоритм:
1. БД получает очередное значение в t1.a1;
2a. Если такое значение есть в t2.a2, то БД добавит данную строку в итоговую таблицу;
2b. Если такого значения нет в t2.a2, то БД тоже добавит данную строку в итоговую таблицу.
    В такой строке все колонки из t2 будут null;
3. БД переходит к таблице t2;
4. БД получает очередное значение в t2.a2;
5a. Если значение t2.a2 уже попало в итоговую таблицу, то БД переходит к следующему значению в t2.a2;
5b. Если значение t2.a2 ещё не попало в итоговую таблицу, то БД тоже добавит данную строку в итоговую таблицу.
    В такой строке все колонки из t1 будут null.

Результат:
+------+------+------+------+
|  a1  |  b1  |  a2  |  b2  |
+------+------+------+------+
|  1   |  a   |  1   |  x   |
|  2   |  b   |  2   |  y   |
|  3   |  c   | null | null |
| null | null |  4   |  z   |
+------+------+------+------+


E*. CROSS JOIN
<SELECT * FROM t1, t2>

Такой JOIN соединяет каждую строку из t1 с каждой строкой из t2.
Итоговая таблица будет содержать n1 * n2 строк, где n1 - кол-во строк в t1,
а n2 - кол-во строк в t2.

В PostgreSQL нет ключевого слова CROSS JOIN.
Чтобы такое соединение выполнить необходимо в блоке FROM просто перечислить имена таблиц через запятую.

Алгоритм:
1. Обыкновенное "склеивание" каждой строки из таблицы t1 с каждой строкой из таблицы t2.

Результат:
+------+------+------+------+
|  a1  |  b1  |  a2  |  b2  |
+------+------+------+------+
|  1   |  a   |  1   |  x   |
|  1   |  a   |  2   |  y   |
|  1   |  a   |  4   |  z   |
|  2   |  b   |  1   |  x   |
|  2   |  b   |  2   |  y   |
|  2   |  b   |  3   |  z   |
|  3   |  c   |  1   |  x   |
|  3   |  c   |  2   |  y   |
|  3   |  c   |  4   |  z   |
+------+------+------+------+
*/